# Design Patterns for Microservices

להלן סיווג ודירוג של תבניות עיצוב (Patterns) רלוונטיות לארכיטקטורת מיקרו-שירותים:

---

#### טבלת סיכום תבניות

| Pattern Name                     | מתאים ל-Microservices | הערות                                         |
| -------------------------------- | --------------------- | --------------------------------------------- |
| **Database per Service**             | ✅ כן                  | הפרדת DB לכל שירות, מאפשר סקיילינג ואוטונומיה |
| Shared Database per Service      | ❌ לא                  | יוצר תלות הדדית, לא מומלץ ב-MSA               |
| CQRS                             | ✅ כן                  | הפרדה בין קריאה לכתיבה, משפר ביצועים          |
| **Event Sourcing**                   | ✅ כן                  | עקיבות, שקיפות ויכולת שחזור מצב               |
| Decompose by Business Capability | ✅ כן                  | חלוקה לפי פונקציות עסקיות ברורות              |
| **Decompose by Subdomain (DDD)**     | ✅ כן                  | חלוקה לפי הקשר דומייני והגדרת גבולות          |
| Decompose by Transactions        | ✅ כן                  | לפי טרנזקציות מבודדות                         |
| Strangler Pattern                | ✅ כן                  | מעבר הדרגתי ממונולית ל-MSA                    |
| Sidecar Pattern                  | ✅ כן                  | קונטיינר עזר לפונקציות תשתית                  |
| **Bulkhead Pattern**                 | ✅ כן                  | בידוד רכיבים ומשאבים למניעת קריסה כוללת       |
| **API Gateway Pattern**              | ✅ כן                  | שכבת ניתוב ואבטחה ראשית                       |
| Aggregator Pattern               | ✅ כן                  | שירות שמאגד תוצאות משירותים אחרים             |
| Proxy Pattern                    | ✅ כן                  | תווך בין לקוח לשירותים פנימיים                |
| Gateway Routing Pattern          | ✅ כן                  | ניתוב חכם לפי פרמטרים / URI                   |
| Chained Microservice Pattern     | ✅ כן                  | שרשור קריאות בין שירותים                      |
| Branch Pattern                   | ✅ כן                  | קריאות מקביליות למספר שירותים                 |
| **Log Aggregation**                  | ✅ כן                  | ריכוז לוגים מרכזי לחיפוש וניתוח               |
| **Performance Metrics**              | ✅ כן                  | מדדי ביצועים לצווארי בקבוק                    |
| Distributed Tracing              | ✅ כן                  | Trace מלא בין שירותים                         |
| **Health Check**                     | ✅ כן                  | בדיקת זמינות עבור Orchestrator                |
| **External Configuration**           | ✅ כן                  | ניהול קונפיגורציה חיצונית לקוד                |
| **Circuit Breaker Pattern**          | ✅ כן                  | ניתוק שירותים שגורמים לשגיאות קשות            |
| **Blue-Green Deployment**            | ✅ כן                  | עדכונים ללא השבתה                             |
| Service Discovery Pattern        | ✅ כן                  | גילוי דינמי של שירותים                        |
| Client-Side UI Composition       | ✅ כן                  | Micro Frontends – חלוקה של ה-UI בין צוותים    |



---
### 🧱 1. Database per Service

**תיאור:**
לכל מיקרו-שירות יש מסד נתונים משלו, מנותק ממסדי נתונים של שירותים אחרים.

**מתי להשתמש:**
כאשר רוצים בידוד נתונים, אוטונומיה של שירותים, יכולת סקיילינג וניהול שונה של טכנולוגיות אחסון.

**יתרונות:**

* שירותים עצמאיים
* ניתן לבחור טכנולוגיית DB שונה לכל שירות
* מאפשר סקיילינג עצמאי

**חסרונות:**

* קושי בביצוע טרנזקציות חוצות שירותים
* סיבוכיות גבוהה בשאילתות משולבות
* צורך ב-CQRS/Event Sourcing

---

### 🧱 2. Shared Database per Service

**תיאור:**
כל השירותים (או כל רכיבי המערכת) משתמשים במסד נתונים מרכזי אחד.

**מתי להשתמש:**
במערכות קטנות, או בתחילת פיתוח, כאשר אין עדיין הפרדה ברורה בין שירותים.

**יתרונות:**

* קל לפתח ולבדוק
* שאילתות בין רכיבים פשוטות

**חסרונות:**

* קושי להפריד שירותים בעתיד
* תלות הדדית גבוהה
* צוואר בקבוק במסד הנתונים

---

### 🧱 3. Event Sourcing

**תיאור:**
כל שינוי במידע נשמר כאירוע בלוג, במקום לשמור את המצב הנוכחי בלבד.

**מתי להשתמש:**
כשנדרש לעקוב אחר כל השינויים (audit), לאפשר שחזור מצב, או להשתמש ב-Event Driven Architecture.

**יתרונות:**

* שקיפות מלאה של היסטוריית שינויים
* אפשרות לשחזור מצב בכל נקודת זמן
* מתאים לאינטגרציה עם Kafka

**חסרונות:**

* לוגיקה מורכבת
* צורך בתשתית לניהול האירועים

---

### 🧱 4. Saga

**תיאור:**
ניהול טרנזקציות מבוזרות באמצעות סדרת פעולות + פעולות פיצוי במקרה של כשל.

**מתי להשתמש:**
במקום טרנזקציות ACID חוצות שירותים, כשיש תלות בין מספר שירותים בתהליך עסקי.

**יתרונות:**

* עקביות סופית (Eventually Consistent)
* מתאים למיקרו-שירותים
* תומך ב-Compensation Logic

**חסרונות:**

* לוגיקה מורכבת לניהול סאגה
* טיפול בשגיאות לא טריוויאלי

---

### 🧱 5. Bulkhead

**תיאור:**
בידוד משאבים כך שכל שירות או רכיב לא יפגע באחרים במקרה של תקלה או עומס.

**מתי להשתמש:**
כאשר שירותים משתפים תשתיות או עובדים בסביבת multi-tenant.

**יתרונות:**

* בידוד תקלות
* שמירה על זמינות חלקית
* עמידות תחת עומסים

**חסרונות:**

* עלות משאבים גבוהה יותר
* צורך בניהול מדויק של מחיצות

---

### 🧱 6. Circuit Breaker

**תיאור:**
מונע קריאות לשירותים לא זמינים ע"י פתיחת "מעגל" לזמן קצוב לאחר שגיאות חוזרות.

**מתי להשתמש:**
כאשר שירותים תלויים זה בזה והכשל של אחד מהם עלול לגרום ל-cascading failure.

**יתרונות:**

* מניעת קריסות שרשרת
* שיפור יציבות כללית
* מאפשר fallback

**חסרונות:**

* דורש ניטור מדויק
* הגדרות רגישות מדי עלולות לחסום שירותים תקינים

---

### 🧱 7. API Gateway

**תיאור:**
שכבת תיווך שמרכזת את הבקשות מהממשקים החיצוניים ומנתבת אותן לשירותים הרלוונטיים.

**מתי להשתמש:**
במערכות עם הרבה מיקרו-שירותים שצריכים לנהל Authentication, Rate limiting, וכו'.

**יתרונות:**

* ריכוז ניהול
* אבטחה, Caching, ניתוב
* הפשטה ללקוח

**חסרונות:**

* Single point of failure
* מורכבות נוספת

---


תרגיל לקורס DevOps

שם התרגיל:
ניתוח תבניות עיצוב באתר תוכן מבוסס מיקרו־שירותים (דוגמת Netflix)

רקע:
אתר כמו Netflix מציע תוכן וידאו למיליוני משתמשים בו זמנית, על גבי מגוון מכשירים, תוך התאמה אישית, ביצועים גבוהים, והמשכיות עבודה גם בתקלות. מערכת כזו בנויה על עקרונות DevOps ומיקרו־שירותים.

משימה:
בחרו שירות תכנים כלשהו (אמיתי או מדומה – למשל Netflix, Disney+, או שירות שאתם ממציאים) וענו על השאלות הבאות:

🔍 שלבים:

אפיון כללי של המערכת:

מה סוג התכנים שהיא מספקת?

אילו מרכיבים קיימים (חיפוש, המלצות, סטרימינג, ניהול משתמשים)?

זיהוי מיקרו־שירותים:

פרטו 3–5 מיקרו־שירותים אפשריים במערכת (למשל: שירות תכנים, שירות המלצות, שירות ניהול משתמשים).

בחירת תבניות עיצוב:

בחרו לפחות 5 תבניות עיצוב מהרשימה במסמך הקורס.

עבור כל אחת מהתבניות, ענו:

באיזה רכיב תשתמשו בה?

מה הבעיה שהיא פותרת?

איך היא תיושם בפועל?

-----